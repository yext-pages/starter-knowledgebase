"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilterGroup = void 0;
const react_1 = require("react");
const jsx_runtime_1 = require("react/jsx-runtime");
const search_headless_react_1 = require("@yext/search-headless-react");
const react_2 = require("react");
const Filters_1 = require("./Filters");
/**
 * Renders a group of selectable filters with support for searching and collapsing.
 */
function FilterGroup({ fieldId, filterOptions, title, collapsible = true, defaultExpanded = true, searchable, customCssClasses = {}, showMoreLimit = filterOptions.length, children }) {
    const cssClasses = (0, react_2.useMemo)(() => {
        const { option, optionLabel, optionInput } = customCssClasses, remainingClasses = __rest(customCssClasses, ["option", "optionLabel", "optionInput"]);
        return Object.assign(Object.assign(Object.assign(Object.assign({}, remainingClasses), option && { optionContainer: option }), optionLabel && { label: optionLabel }), optionInput && { input: optionInput });
    }, [customCssClasses]);
    function renderTitle() {
        return collapsible
            ? (0, jsx_runtime_1.jsx)(Filters_1.CollapsibleLabel, { label: title }, void 0)
            : (title &&
                (0, jsx_runtime_1.jsx)("div", Object.assign({ className: 'text-neutral-dark text-sm font-medium text-left mb-4' }, { children: title }), void 0));
    }
    return ((0, jsx_runtime_1.jsxs)(Filters_1.FilterGroupProvider, Object.assign({ fieldId: fieldId, defaultExpanded: !collapsible || defaultExpanded }, { children: [renderTitle(), (0, jsx_runtime_1.jsxs)(Filters_1.CollapsibleSection, Object.assign({ className: cssClasses.optionsContainer }, { children: [searchable && (0, jsx_runtime_1.jsx)(Filters_1.SearchInput, { className: cssClasses.searchInput }, void 0), (0, jsx_runtime_1.jsx)(CheckboxOptions, { filterOptions: filterOptions, showMoreLimit: showMoreLimit, cssClasses: cssClasses }, void 0), children] }), void 0)] }), void 0));
}
exports.FilterGroup = FilterGroup;
function CheckboxOptions({ filterOptions, showMoreLimit, cssClasses }) {
    const searchUtilities = (0, search_headless_react_1.useSearchUtilities)();
    const { searchValue } = (0, Filters_1.useFilterGroupContext)();
    const shouldRenderOption = (option) => {
        return searchUtilities.isCloseMatch(option.displayName || option.value.toString(), searchValue);
    };
    let displayedOptions = filterOptions.filter(shouldRenderOption).map(o => {
        return ((0, react_1.createElement)(Filters_1.CheckboxOption, Object.assign({}, o, { key: o.displayName || o.value.toString(), customCssClasses: cssClasses })));
    });
    const isLimited = displayedOptions.length > showMoreLimit;
    const [showAll, setShowAll] = (0, react_2.useState)(!isLimited);
    displayedOptions = displayedOptions.slice(0, showAll ? displayedOptions.length : showMoreLimit);
    return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [displayedOptions, isLimited &&
                /* eslint-disable-next-line react-perf/jsx-no-new-function-as-prop */
                (0, jsx_runtime_1.jsx)("button", Object.assign({ className: 'text-primary py-1 text-sm', onClick: () => setShowAll(!showAll) }, { children: showAll ? 'Show Less' : 'Show More' }), void 0)] }, void 0));
}
//# sourceMappingURL=FilterGroup.js.map