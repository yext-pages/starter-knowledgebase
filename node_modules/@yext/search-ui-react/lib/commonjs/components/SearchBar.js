"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateEntityPreviewsCount = exports.SearchBar = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const search_headless_react_1 = require("@yext/search-headless-react");
const classnames_1 = __importDefault(require("classnames"));
const react_1 = require("react");
const useEntityPreviews_1 = require("../hooks/useEntityPreviews");
const useRecentSearches_1 = require("../hooks/useRecentSearches");
const useSearchWithNearMeHandling_1 = require("../hooks/useSearchWithNearMeHandling");
const useSynchronizedRequest_1 = require("../hooks/useSynchronizedRequest");
const VerticalDividerIcon_1 = require("../icons/VerticalDividerIcon");
const HistoryIcon_1 = require("../icons/HistoryIcon");
const CloseIcon_1 = require("../icons/CloseIcon");
const MagnifyingGlassIcon_1 = require("../icons/MagnifyingGlassIcon");
const YextIcon_1 = require("../icons/YextIcon");
const Dropdown_1 = require("./Dropdown/Dropdown");
const DropdownContext_1 = require("./Dropdown/DropdownContext");
const DropdownInput_1 = require("./Dropdown/DropdownInput");
const DropdownItem_1 = require("./Dropdown/DropdownItem");
const DropdownMenu_1 = require("./Dropdown/DropdownMenu");
const useComposedCssClasses_1 = require("../hooks/useComposedCssClasses");
const SearchButton_1 = require("./SearchButton");
const processTranslation_1 = require("./utils/processTranslation");
const renderAutocompleteResult_1 = require("./utils/renderAutocompleteResult");
const useSearchBarAnalytics_1 = require("../hooks/useSearchBarAnalytics");
const verticalLink_1 = require("../models/verticalLink");
const search_operations_1 = require("../utils/search-operations");
const filterutils_1 = require("../utils/filterutils");
const recursivelyMapChildren_1 = require("./utils/recursivelyMapChildren");
const builtInCssClasses = Object.assign({ searchBarContainer: 'h-12 mb-6', inputDivider: 'border-t border-gray-200 mx-2.5', inputElement: 'outline-none flex-grow border-none h-full pl-0.5 pr-2 text-neutral-dark text-base placeholder:text-neutral-light', searchButtonContainer: ' w-8 h-full mx-2 flex flex-col justify-center items-center', searchButton: 'h-7 w-7', focusedOption: 'bg-gray-100', clearButton: 'h-3 w-3 mr-3.5', verticalDivider: 'mr-0.5', recentSearchesIcon: 'w-5 mr-1 text-gray-400', recentSearchesOption: 'pl-3 text-neutral-dark', recentSearchesNonHighlighted: 'font-normal', verticalLink: 'ml-12 pl-1 text-neutral italic', entityPreviewsDivider: 'h-px bg-gray-200 mt-1 mb-4 mx-3.5' }, renderAutocompleteResult_1.builtInCssClasses);
/**
 * Renders a SearchBar that is hooked up with an InputDropdown component.
 *
 * @public
 */
function SearchBar({ placeholder, geolocationOptions, hideRecentSearches, visualAutocompleteConfig, showVerticalLinks = false, onSelectVerticalLink, verticalKeyToLabel, recentSearchesLimit = 5, customCssClasses, onSearch }) {
    var _a;
    const { entityPreviewSearcher, renderEntityPreviews, includedVerticals, universalLimit, entityPreviewsDebouncingTime = 500 } = visualAutocompleteConfig !== null && visualAutocompleteConfig !== void 0 ? visualAutocompleteConfig : {};
    const searchActions = (0, search_headless_react_1.useSearchActions)();
    const searchUtilities = (0, search_headless_react_1.useSearchUtilities)();
    const reportAnalyticsEvent = (0, useSearchBarAnalytics_1.useSearchBarAnalytics)();
    const query = (_a = (0, search_headless_react_1.useSearchState)(state => state.query.input)) !== null && _a !== void 0 ? _a : '';
    const cssClasses = (0, useComposedCssClasses_1.useComposedCssClasses)(builtInCssClasses, customCssClasses);
    const isVertical = (0, search_headless_react_1.useSearchState)(state => state.meta.searchType) === search_headless_react_1.SearchTypeEnum.Vertical;
    const verticalKey = (0, search_headless_react_1.useSearchState)(state => state.vertical.verticalKey);
    const [autocompleteResponse, executeAutocomplete, clearAutocompleteData] = (0, useSynchronizedRequest_1.useSynchronizedRequest)(() => (0, search_operations_1.executeAutocomplete)(searchActions));
    const [executeQueryWithNearMeHandling, autocompletePromiseRef,] = (0, useSearchWithNearMeHandling_1.useSearchWithNearMeHandling)(geolocationOptions, onSearch);
    const [recentSearches, setRecentSearch, clearRecentSearches,] = (0, useRecentSearches_1.useRecentSearches)(recentSearchesLimit, verticalKey);
    const filteredRecentSearches = recentSearches === null || recentSearches === void 0 ? void 0 : recentSearches.filter(search => searchUtilities.isCloseMatch(search.query, query));
    (0, react_1.useEffect)(() => {
        if (hideRecentSearches) {
            clearRecentSearches();
        }
    }, [clearRecentSearches, hideRecentSearches]);
    const clearAutocomplete = (0, react_1.useCallback)(() => {
        clearAutocompleteData();
        autocompletePromiseRef.current = undefined;
    }, [autocompletePromiseRef, clearAutocompleteData]);
    const executeQuery = (0, react_1.useCallback)(() => {
        if (!hideRecentSearches) {
            const input = searchActions.state.query.input;
            input && setRecentSearch(input);
        }
        executeQueryWithNearMeHandling();
    }, [
        searchActions.state.query.input,
        executeQueryWithNearMeHandling,
        hideRecentSearches,
        setRecentSearch
    ]);
    const handleSubmit = (0, react_1.useCallback)((value, index, itemData) => {
        value !== undefined && searchActions.setQuery(value);
        searchActions.setOffset(0);
        searchActions.setFacets([]);
        (0, filterutils_1.clearStaticRangeFilters)(searchActions);
        if (itemData && (0, verticalLink_1.isVerticalLink)(itemData.verticalLink) && onSelectVerticalLink) {
            onSelectVerticalLink({ verticalLink: itemData.verticalLink, querySource: search_headless_react_1.QuerySource.Autocomplete });
        }
        else {
            executeQuery();
        }
        if (typeof index === 'number' && index >= 0 && !(itemData === null || itemData === void 0 ? void 0 : itemData.isEntityPreview)) {
            reportAnalyticsEvent('AUTO_COMPLETE_SELECTION', value);
        }
    }, [searchActions, executeQuery, onSelectVerticalLink, reportAnalyticsEvent]);
    const [entityPreviewsState, executeEntityPreviewsQuery] = (0, useEntityPreviews_1.useEntityPreviews)(entityPreviewSearcher, entityPreviewsDebouncingTime);
    const { verticalKeyToResults, isLoading: entityPreviewsLoading } = entityPreviewsState;
    const entityPreviews = renderEntityPreviews === null || renderEntityPreviews === void 0 ? void 0 : renderEntityPreviews(entityPreviewsLoading, verticalKeyToResults, { onClick: handleSubmit, ariaLabel: getAriaLabel });
    const updateEntityPreviews = (0, react_1.useCallback)((query) => {
        if (!renderEntityPreviews || !includedVerticals) {
            return;
        }
        executeEntityPreviewsQuery(query, universalLimit !== null && universalLimit !== void 0 ? universalLimit : {}, includedVerticals);
    }, [executeEntityPreviewsQuery, renderEntityPreviews, includedVerticals, universalLimit]);
    const handleInputFocus = (0, react_1.useCallback)((value = '') => {
        searchActions.setQuery(value);
        updateEntityPreviews(value);
        autocompletePromiseRef.current = executeAutocomplete();
    }, [searchActions, autocompletePromiseRef, executeAutocomplete, updateEntityPreviews]);
    const handleInputChange = (0, react_1.useCallback)((value = '') => {
        searchActions.setQuery(value);
        updateEntityPreviews(value);
        autocompletePromiseRef.current = executeAutocomplete();
    }, [searchActions, autocompletePromiseRef, executeAutocomplete, updateEntityPreviews]);
    const handleClickClearButton = (0, react_1.useCallback)(() => {
        updateEntityPreviews('');
        handleSubmit('');
        reportAnalyticsEvent('SEARCH_CLEAR_BUTTON');
    }, [handleSubmit, reportAnalyticsEvent, updateEntityPreviews]);
    function renderInput() {
        return ((0, jsx_runtime_1.jsx)(DropdownInput_1.DropdownInput, { className: cssClasses.inputElement, placeholder: placeholder, onSubmit: handleSubmit, onFocus: handleInputFocus, onChange: handleInputChange, ariaLabel: 'Conduct a search' }, void 0));
    }
    function renderRecentSearches() {
        const recentSearchesCssClasses = {
            icon: cssClasses.recentSearchesIcon,
            option: cssClasses.recentSearchesOption,
            nonHighlighted: cssClasses.recentSearchesNonHighlighted
        };
        return filteredRecentSearches === null || filteredRecentSearches === void 0 ? void 0 : filteredRecentSearches.map((result, i) => ((0, jsx_runtime_1.jsx)(DropdownItem_1.DropdownItem, Object.assign({ className: 'flex items-center h-6.5 px-3.5 py-1.5 cursor-pointer hover:bg-gray-100', focusedClassName: (0, useComposedCssClasses_1.twMerge)('flex items-center h-6.5 px-3.5 py-1.5 cursor-pointer hover:bg-gray-100', cssClasses.focusedOption), value: result.query, onClick: handleSubmit }, { children: (0, renderAutocompleteResult_1.renderAutocompleteResult)({ value: result.query }, recentSearchesCssClasses, HistoryIcon_1.HistoryIcon, `recent search: ${result.query}`) }), i)));
    }
    const itemDataMatrix = (0, react_1.useMemo)(() => {
        var _a;
        return (_a = autocompleteResponse === null || autocompleteResponse === void 0 ? void 0 : autocompleteResponse.results.map(result => {
            var _a, _b;
            return (_b = (_a = result.verticalKeys) === null || _a === void 0 ? void 0 : _a.map(verticalKey => ({
                verticalLink: { verticalKey, query: result.value }
            }))) !== null && _b !== void 0 ? _b : [];
        })) !== null && _a !== void 0 ? _a : [];
    }, [autocompleteResponse === null || autocompleteResponse === void 0 ? void 0 : autocompleteResponse.results]);
    function renderQuerySuggestions() {
        return autocompleteResponse === null || autocompleteResponse === void 0 ? void 0 : autocompleteResponse.results.map((result, i) => {
            var _a;
            return ((0, jsx_runtime_1.jsxs)(react_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(DropdownItem_1.DropdownItem, Object.assign({ className: 'flex items-stretch py-1.5 px-3.5 cursor-pointer hover:bg-gray-100', focusedClassName: (0, useComposedCssClasses_1.twMerge)('flex items-stretch py-1.5 px-3.5 cursor-pointer hover:bg-gray-100', cssClasses.focusedOption), value: result.value, onClick: handleSubmit }, { children: (0, renderAutocompleteResult_1.renderAutocompleteResult)(result, cssClasses, MagnifyingGlassIcon_1.MagnifyingGlassIcon, `autocomplete suggestion: ${result.value}`) }), void 0), showVerticalLinks && !isVertical && ((_a = result.verticalKeys) === null || _a === void 0 ? void 0 : _a.map((verticalKey, j) => ((0, jsx_runtime_1.jsx)(DropdownItem_1.DropdownItem, Object.assign({ className: 'flex items-stretch py-1.5 px-3.5 cursor-pointer hover:bg-gray-100', focusedClassName: (0, useComposedCssClasses_1.twMerge)('flex items-stretch py-1.5 px-3.5 cursor-pointer hover:bg-gray-100', cssClasses.focusedOption), value: result.value, itemData: itemDataMatrix[i][j], onClick: handleSubmit }, { children: (0, renderAutocompleteResult_1.renderAutocompleteResult)({ value: `in ${verticalKeyToLabel ? verticalKeyToLabel(verticalKey) : verticalKey}` }, Object.assign(Object.assign({}, cssClasses), { option: cssClasses.verticalLink })) }), j))))] }, i));
        });
    }
    function renderClearButton() {
        return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)("button", Object.assign({ "aria-label": 'Clear the search bar', className: cssClasses.clearButton, onClick: handleClickClearButton }, { children: (0, jsx_runtime_1.jsx)(CloseIcon_1.CloseIcon, {}, void 0) }), void 0), (0, jsx_runtime_1.jsx)(VerticalDividerIcon_1.VerticalDividerIcon, { className: cssClasses.verticalDivider }, void 0)] }, void 0));
    }
    const entityPreviewsCount = calculateEntityPreviewsCount(entityPreviews);
    const showEntityPreviewsDivider = entityPreviews
        && !!((autocompleteResponse === null || autocompleteResponse === void 0 ? void 0 : autocompleteResponse.results.length) || (filteredRecentSearches === null || filteredRecentSearches === void 0 ? void 0 : filteredRecentSearches.length));
    const hasItems = !!((autocompleteResponse === null || autocompleteResponse === void 0 ? void 0 : autocompleteResponse.results.length)
        || (filteredRecentSearches === null || filteredRecentSearches === void 0 ? void 0 : filteredRecentSearches.length) || entityPreviews);
    const screenReaderText = getScreenReaderText(autocompleteResponse === null || autocompleteResponse === void 0 ? void 0 : autocompleteResponse.results.length, filteredRecentSearches === null || filteredRecentSearches === void 0 ? void 0 : filteredRecentSearches.length, entityPreviewsCount);
    const activeClassName = (0, classnames_1.default)('relative z-10 bg-white border rounded-3xl border-gray-200 w-full overflow-hidden', {
        ['shadow-lg' !== null && 'shadow-lg' !== void 0 ? 'shadow-lg' : '']: hasItems
    });
    const handleToggleDropdown = (0, react_1.useCallback)((isActive) => {
        if (!isActive) {
            clearAutocomplete();
        }
    }, [clearAutocomplete]);
    return ((0, jsx_runtime_1.jsx)("div", Object.assign({ className: cssClasses.searchBarContainer }, { children: (0, jsx_runtime_1.jsxs)(Dropdown_1.Dropdown, Object.assign({ className: 'relative bg-white border rounded-3xl border-gray-200 w-full overflow-hidden', activeClassName: activeClassName, screenReaderText: screenReaderText, parentQuery: query, onToggle: handleToggleDropdown }, { children: [(0, jsx_runtime_1.jsxs)("div", Object.assign({ className: 'inline-flex items-center justify-between w-full' }, { children: [(0, jsx_runtime_1.jsx)("div", Object.assign({ className: 'w-7 mx-2.5 my-2' }, { children: (0, jsx_runtime_1.jsx)(YextIcon_1.YextIcon, {}, void 0) }), void 0), renderInput(), query && renderClearButton(), (0, jsx_runtime_1.jsx)(DropdownSearchButton, { handleSubmit: handleSubmit, cssClasses: cssClasses }, void 0)] }), void 0), hasItems &&
                    (0, jsx_runtime_1.jsxs)(StyledDropdownMenu, Object.assign({ cssClasses: cssClasses }, { children: [renderRecentSearches(), renderQuerySuggestions(), showEntityPreviewsDivider && (0, jsx_runtime_1.jsx)("div", { className: cssClasses.entityPreviewsDivider }, void 0), entityPreviews] }), void 0)] }), void 0) }), void 0));
}
exports.SearchBar = SearchBar;
function StyledDropdownMenu({ cssClasses, children }) {
    return ((0, jsx_runtime_1.jsxs)(DropdownMenu_1.DropdownMenu, { children: [(0, jsx_runtime_1.jsx)("div", { className: cssClasses.inputDivider }, void 0), (0, jsx_runtime_1.jsx)("div", Object.assign({ className: 'bg-white py-4' }, { children: children }), void 0)] }, void 0));
}
function getScreenReaderText(autocompleteOptions = 0, recentSearchesOptions = 0, entityPreviewsCount = 0) {
    const recentSearchesText = recentSearchesOptions > 0
        ? (0, processTranslation_1.processTranslation)({
            phrase: `${recentSearchesOptions} recent search found.`,
            pluralForm: `${recentSearchesOptions} recent searches found.`,
            count: recentSearchesOptions
        })
        : '';
    const entityPreviewsText = entityPreviewsCount > 0
        ? ' ' + (0, processTranslation_1.processTranslation)({
            phrase: `${entityPreviewsCount} result preview found.`,
            pluralForm: `${entityPreviewsCount} result previews found.`,
            count: entityPreviewsCount
        })
        : '';
    const autocompleteText = autocompleteOptions > 0
        ? ' ' + (0, processTranslation_1.processTranslation)({
            phrase: `${autocompleteOptions} autocomplete suggestion found.`,
            pluralForm: `${autocompleteOptions} autocomplete suggestions found.`,
            count: autocompleteOptions
        })
        : '';
    const text = recentSearchesText + autocompleteText + entityPreviewsText;
    if (text === '') {
        return (0, processTranslation_1.processTranslation)({
            phrase: '0 autocomplete suggestion found.',
            pluralForm: '0 autocomplete suggestions found.',
            count: 0
        });
    }
    return text.trim();
}
function DropdownSearchButton({ handleSubmit, cssClasses }) {
    const { toggleDropdown } = (0, DropdownContext_1.useDropdownContext)();
    const handleClick = (0, react_1.useCallback)(() => {
        handleSubmit();
        toggleDropdown(false);
    }, [handleSubmit, toggleDropdown]);
    return ((0, jsx_runtime_1.jsx)("div", Object.assign({ className: cssClasses.searchButtonContainer }, { children: (0, jsx_runtime_1.jsx)(SearchButton_1.SearchButton, { className: cssClasses.searchButton, handleClick: handleClick }, void 0) }), void 0));
}
function getAriaLabel(value) {
    return 'result preview: ' + value;
}
/**
 * Calculates the number of navigable entity previews from a ReactNode containing DropdownItems.
 */
function calculateEntityPreviewsCount(children) {
    let count = 0;
    (0, recursivelyMapChildren_1.recursivelyMapChildren)(children, c => {
        if ((0, react_1.isValidElement)(c) && c.type === DropdownItem_1.DropdownItem) {
            count++;
        }
        return c;
    });
    return count;
}
exports.calculateEntityPreviewsCount = calculateEntityPreviewsCount;
//# sourceMappingURL=SearchBar.js.map