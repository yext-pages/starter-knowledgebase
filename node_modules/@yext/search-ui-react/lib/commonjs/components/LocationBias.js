"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocationBias = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const search_headless_react_1 = require("@yext/search-headless-react");
const search_operations_1 = require("../utils/search-operations");
const location_operations_1 = require("../utils/location-operations");
const useComposedCssClasses_1 = require("../hooks/useComposedCssClasses");
const react_1 = require("react");
const LoadingIndicator_1 = __importDefault(require("../icons/LoadingIndicator"));
const builtInCssClasses = {
    locationBiasContainer: 'text-sm text-neutral text-center justify-center items-center flex flex-col lg:flex-row',
    location: 'font-semibold lg:ml-7',
    source: 'ml-3 lg:ml-0 whitespace-pre',
    button: 'text-primary hover:underline focus:underline ml-7 lg:ml-0',
    loadingIndicatorContainer: 'w-4 h-4 ml-3 shrink-0'
};
/**
 * A React Component which displays and collects location information in order to bias searches.
 *
 * @public
 *
 * @param props - {@link LocationBiasProps}
 * @returns A react component for Location Bias
 */
function LocationBias({ geolocationOptions, customCssClasses }) {
    const searchActions = (0, search_headless_react_1.useSearchActions)();
    const locationBias = (0, search_headless_react_1.useSearchState)(s => s.location.locationBias);
    const [isFetchingLocation, setIsFetchingLocation] = (0, react_1.useState)(false);
    const cssClasses = (0, useComposedCssClasses_1.useComposedCssClasses)(builtInCssClasses, customCssClasses);
    const loadingIndicatorCss = (0, useComposedCssClasses_1.twMerge)(cssClasses.loadingIndicatorContainer, (!isFetchingLocation && 'invisible'));
    if (!(locationBias === null || locationBias === void 0 ? void 0 : locationBias.displayName))
        return null;
    const attributionMessage = (locationBias === null || locationBias === void 0 ? void 0 : locationBias.method) === search_headless_react_1.LocationBiasMethod.Ip ? ' (based on your internet address)'
        : (locationBias === null || locationBias === void 0 ? void 0 : locationBias.method) === search_headless_react_1.LocationBiasMethod.Device ? ' (based on your device)'
            : '';
    async function handleGeolocationClick() {
        setIsFetchingLocation(true);
        try {
            const position = await (0, location_operations_1.getUserLocation)(geolocationOptions);
            searchActions.setUserLocation({
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
            });
        }
        catch (e) {
            console.error(e);
        }
        finally {
            setIsFetchingLocation(false);
        }
        (0, search_operations_1.executeSearch)(searchActions);
    }
    return ((0, jsx_runtime_1.jsxs)("div", Object.assign({ className: cssClasses.locationBiasContainer }, { children: [(0, jsx_runtime_1.jsx)("span", Object.assign({ className: cssClasses.location }, { children: locationBias.displayName }), void 0), (0, jsx_runtime_1.jsxs)("span", Object.assign({ className: cssClasses.source }, { children: [attributionMessage, (0, jsx_runtime_1.jsx)("span", Object.assign({ className: 'invisible lg:visible' }, { children: " - " }), void 0)] }), void 0), (0, jsx_runtime_1.jsxs)("div", Object.assign({ className: 'flex flex-row items-center' }, { children: [(0, jsx_runtime_1.jsx)("button", Object.assign({ className: cssClasses.button, onClick: handleGeolocationClick }, { children: "Update your location" }), void 0), (0, jsx_runtime_1.jsx)("div", Object.assign({ className: loadingIndicatorCss }, { children: (0, jsx_runtime_1.jsx)(LoadingIndicator_1.default, {}, void 0) }), void 0)] }), void 0)] }), void 0));
}
exports.LocationBias = LocationBias;
//# sourceMappingURL=LocationBias.js.map