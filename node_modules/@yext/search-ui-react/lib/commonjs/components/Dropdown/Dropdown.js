"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dropdown = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const DropdownContext_1 = require("./DropdownContext");
const InputContext_1 = require("./InputContext");
const useGlobalListener_1 = __importDefault(require("@restart/hooks/useGlobalListener"));
const useRootClose_1 = __importDefault(require("@restart/ui/useRootClose"));
const FocusContext_1 = require("./FocusContext");
const uuid_1 = require("uuid");
const ScreenReader_1 = require("../ScreenReader");
const recursivelyMapChildren_1 = require("../utils/recursivelyMapChildren");
const DropdownItem_1 = require("./DropdownItem");
const use_isomorphic_layout_effect_1 = __importDefault(require("use-isomorphic-layout-effect"));
/**
 * Dropdown is the parent component for a set of Dropdown-related components.
 *
 * @remarks
 * It provides multiple shared contexts, which are consumed by its child components,
 * and also registers some global event listeners.
 */
function Dropdown(props) {
    const { children, screenReaderText, screenReaderInstructions = 'When autocomplete results are available, use up and down arrows to review and enter to select.', onSelect, onToggle, className, activeClassName, parentQuery, alwaysSelectOption = false } = props;
    const containerRef = (0, react_1.useRef)(null);
    const screenReaderUUID = (0, react_1.useMemo)(() => (0, uuid_1.v4)(), []);
    const [screenReaderKey, setScreenReaderKey] = (0, react_1.useState)(0);
    const [hasTyped, setHasTyped] = (0, react_1.useState)(false);
    const [childrenWithDropdownItemsTransformed, items] = (0, react_1.useMemo)(() => {
        return getTransformedChildrenAndItemData(children);
    }, [children]);
    const inputContext = useInputContextInstance();
    const { value, setValue, lastTypedOrSubmittedValue, setLastTypedOrSubmittedValue } = inputContext;
    const focusContext = useFocusContextInstance(items, lastTypedOrSubmittedValue, setValue, screenReaderKey, setScreenReaderKey, alwaysSelectOption);
    const { focusedIndex, focusedItemData, updateFocusedItem } = focusContext;
    const dropdownContext = useDropdownContextInstance(lastTypedOrSubmittedValue, value, focusedIndex, focusedItemData, screenReaderUUID, setHasTyped, onToggle, onSelect);
    const { toggleDropdown, isActive } = dropdownContext;
    (0, use_isomorphic_layout_effect_1.default)(() => {
        if (parentQuery !== undefined && parentQuery !== lastTypedOrSubmittedValue) {
            setLastTypedOrSubmittedValue(parentQuery);
            updateFocusedItem(-1, parentQuery);
        }
    }, [
        parentQuery,
        lastTypedOrSubmittedValue,
        updateFocusedItem,
        setLastTypedOrSubmittedValue
    ]);
    (0, useRootClose_1.default)(containerRef, () => {
        toggleDropdown(false);
    }, { disabled: !isActive });
    (0, useGlobalListener_1.default)('keydown', e => {
        if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
            e.preventDefault();
        }
        if (!isActive) {
            return;
        }
        if (e.key === 'ArrowDown') {
            if (alwaysSelectOption && focusedIndex === items.length - 1) {
                updateFocusedItem(0);
            }
            else {
                updateFocusedItem(focusedIndex + 1);
            }
        }
        else if (e.key === 'ArrowUp') {
            if (alwaysSelectOption && focusedIndex === 0) {
                updateFocusedItem(items.length - 1);
            }
            else {
                updateFocusedItem(focusedIndex - 1);
            }
        }
        else if (e.key === 'Tab' && !e.shiftKey) {
            if (items.length !== 0) {
                if (focusedIndex >= items.length - 1) {
                    updateFocusedItem(-1);
                    toggleDropdown(false);
                }
                else {
                    updateFocusedItem(focusedIndex + 1);
                    e.preventDefault();
                }
            }
        }
        else if (e.key === 'Tab' && e.shiftKey) {
            if (focusedIndex > 0 || (!alwaysSelectOption && focusedIndex === 0)) {
                updateFocusedItem(focusedIndex - 1);
                e.preventDefault();
            }
            else {
                updateFocusedItem(-1);
                toggleDropdown(false);
            }
        }
        else if (!hasTyped) {
            setHasTyped(true);
        }
    });
    return ((0, jsx_runtime_1.jsxs)("div", Object.assign({ ref: containerRef, className: isActive ? activeClassName : className }, { children: [(0, jsx_runtime_1.jsx)(DropdownContext_1.DropdownContext.Provider, Object.assign({ value: dropdownContext }, { children: (0, jsx_runtime_1.jsx)(InputContext_1.InputContext.Provider, Object.assign({ value: inputContext }, { children: (0, jsx_runtime_1.jsx)(FocusContext_1.FocusContext.Provider, Object.assign({ value: focusContext }, { children: childrenWithDropdownItemsTransformed }), void 0) }), void 0) }), void 0), (0, jsx_runtime_1.jsx)(ScreenReader_1.ScreenReader, { announcementKey: screenReaderKey, announcementText: isActive && (hasTyped || items.length || value) ? screenReaderText : '', instructionsId: screenReaderUUID, instructions: screenReaderInstructions }, void 0)] }), void 0));
}
exports.Dropdown = Dropdown;
function useInputContextInstance() {
    const [value, setValue] = (0, react_1.useState)('');
    const [lastTypedOrSubmittedValue, setLastTypedOrSubmittedValue] = (0, react_1.useState)('');
    return {
        value,
        setValue,
        lastTypedOrSubmittedValue,
        setLastTypedOrSubmittedValue
    };
}
function useFocusContextInstance(items, lastTypedOrSubmittedValue, setValue, screenReaderKey, setScreenReaderKey, alwaysSelectOption) {
    const [focusedIndex, setFocusedIndex] = (0, react_1.useState)(-1);
    const [focusedValue, setFocusedValue] = (0, react_1.useState)(null);
    const [focusedItemData, setFocusedItemData] = (0, react_1.useState)(undefined);
    (0, react_1.useEffect)(() => {
        if (alwaysSelectOption) {
            if (items.length > 0) {
                const index = focusedIndex === -1 || focusedIndex >= items.length ? 0 : focusedIndex;
                setFocusedIndex(index);
                setFocusedValue(items[index].value);
                setFocusedItemData(items[index].itemData);
            }
            else {
                setFocusedIndex(-1);
                setFocusedValue(null);
                setFocusedItemData(undefined);
            }
        }
    }, [alwaysSelectOption, focusedIndex, items]);
    function updateFocusedItem(updatedFocusedIndex, value) {
        const numItems = items.length;
        let updatedValue;
        if (updatedFocusedIndex === -1 || updatedFocusedIndex >= numItems || numItems === 0) {
            updatedValue = value !== null && value !== void 0 ? value : lastTypedOrSubmittedValue;
            if (alwaysSelectOption && numItems !== 0) {
                setFocusedIndex(0);
                setFocusedItemData(items[0].itemData);
                setScreenReaderKey(screenReaderKey + 1);
            }
            else {
                setFocusedIndex(-1);
                setFocusedItemData(undefined);
                setScreenReaderKey(screenReaderKey + 1);
            }
        }
        else if (updatedFocusedIndex < -1) {
            const loopedAroundIndex = (numItems + updatedFocusedIndex + 1) % numItems;
            updatedValue = value !== null && value !== void 0 ? value : items[loopedAroundIndex].value;
            setFocusedIndex(loopedAroundIndex);
            setFocusedItemData(items[loopedAroundIndex].itemData);
        }
        else {
            updatedValue = value !== null && value !== void 0 ? value : items[updatedFocusedIndex].value;
            setFocusedIndex(updatedFocusedIndex);
            setFocusedItemData(items[updatedFocusedIndex].itemData);
        }
        setFocusedValue(updatedValue);
        setValue(alwaysSelectOption ? (value !== null && value !== void 0 ? value : lastTypedOrSubmittedValue) : updatedValue);
    }
    return {
        focusedIndex,
        focusedValue,
        focusedItemData,
        updateFocusedItem
    };
}
function useDropdownContextInstance(prevValue, value, index, focusedItemData, screenReaderUUID, setHasTyped, onToggle, onSelect) {
    const [isActive, _toggleDropdown] = (0, react_1.useState)(false);
    const toggleDropdown = (willBeOpen) => {
        if (!willBeOpen) {
            setHasTyped(false);
        }
        _toggleDropdown(willBeOpen);
        onToggle === null || onToggle === void 0 ? void 0 : onToggle(willBeOpen, prevValue, value, index, focusedItemData);
    };
    return {
        isActive,
        toggleDropdown,
        onSelect,
        screenReaderUUID
    };
}
function getTransformedChildrenAndItemData(children) {
    const items = [];
    const childrenWithDropdownItemsTransformed = (0, recursivelyMapChildren_1.recursivelyMapChildren)(children, (child => {
        if (!((0, react_1.isValidElement)(child) && child.type === DropdownItem_1.DropdownItem)) {
            return child;
        }
        const props = child.props;
        items.push({
            value: props.value,
            itemData: props.itemData
        });
        const transformedItem = (0, react_1.createElement)(DropdownItem_1.DropdownItemWithIndex, Object.assign(Object.assign({}, props), { index: items.length - 1 }));
        return transformedItem;
    }));
    return [childrenWithDropdownItemsTransformed, items];
}
//# sourceMappingURL=Dropdown.js.map