import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { createElement, isValidElement, useEffect, useMemo, useRef, useState } from 'react';
import { DropdownContext } from './DropdownContext';
import { InputContext } from './InputContext';
import useGlobalListener from '@restart/hooks/useGlobalListener';
import useRootClose from '@restart/ui/useRootClose';
import { FocusContext } from './FocusContext';
import { v4 as uuid } from 'uuid';
import { ScreenReader } from '../ScreenReader';
import { recursivelyMapChildren } from '../utils/recursivelyMapChildren';
import { DropdownItem, DropdownItemWithIndex } from './DropdownItem';
import useLayoutEffect from 'use-isomorphic-layout-effect';
/**
 * Dropdown is the parent component for a set of Dropdown-related components.
 *
 * @remarks
 * It provides multiple shared contexts, which are consumed by its child components,
 * and also registers some global event listeners.
 */
export function Dropdown(props) {
    const { children, screenReaderText, screenReaderInstructions = 'When autocomplete results are available, use up and down arrows to review and enter to select.', onSelect, onToggle, className, activeClassName, parentQuery, alwaysSelectOption = false } = props;
    const containerRef = useRef(null);
    const screenReaderUUID = useMemo(() => uuid(), []);
    const [screenReaderKey, setScreenReaderKey] = useState(0);
    const [hasTyped, setHasTyped] = useState(false);
    const [childrenWithDropdownItemsTransformed, items] = useMemo(() => {
        return getTransformedChildrenAndItemData(children);
    }, [children]);
    const inputContext = useInputContextInstance();
    const { value, setValue, lastTypedOrSubmittedValue, setLastTypedOrSubmittedValue } = inputContext;
    const focusContext = useFocusContextInstance(items, lastTypedOrSubmittedValue, setValue, screenReaderKey, setScreenReaderKey, alwaysSelectOption);
    const { focusedIndex, focusedItemData, updateFocusedItem } = focusContext;
    const dropdownContext = useDropdownContextInstance(lastTypedOrSubmittedValue, value, focusedIndex, focusedItemData, screenReaderUUID, setHasTyped, onToggle, onSelect);
    const { toggleDropdown, isActive } = dropdownContext;
    useLayoutEffect(() => {
        if (parentQuery !== undefined && parentQuery !== lastTypedOrSubmittedValue) {
            setLastTypedOrSubmittedValue(parentQuery);
            updateFocusedItem(-1, parentQuery);
        }
    }, [
        parentQuery,
        lastTypedOrSubmittedValue,
        updateFocusedItem,
        setLastTypedOrSubmittedValue
    ]);
    useRootClose(containerRef, () => {
        toggleDropdown(false);
    }, { disabled: !isActive });
    useGlobalListener('keydown', e => {
        if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
            e.preventDefault();
        }
        if (!isActive) {
            return;
        }
        if (e.key === 'ArrowDown') {
            if (alwaysSelectOption && focusedIndex === items.length - 1) {
                updateFocusedItem(0);
            }
            else {
                updateFocusedItem(focusedIndex + 1);
            }
        }
        else if (e.key === 'ArrowUp') {
            if (alwaysSelectOption && focusedIndex === 0) {
                updateFocusedItem(items.length - 1);
            }
            else {
                updateFocusedItem(focusedIndex - 1);
            }
        }
        else if (e.key === 'Tab' && !e.shiftKey) {
            if (items.length !== 0) {
                if (focusedIndex >= items.length - 1) {
                    updateFocusedItem(-1);
                    toggleDropdown(false);
                }
                else {
                    updateFocusedItem(focusedIndex + 1);
                    e.preventDefault();
                }
            }
        }
        else if (e.key === 'Tab' && e.shiftKey) {
            if (focusedIndex > 0 || (!alwaysSelectOption && focusedIndex === 0)) {
                updateFocusedItem(focusedIndex - 1);
                e.preventDefault();
            }
            else {
                updateFocusedItem(-1);
                toggleDropdown(false);
            }
        }
        else if (!hasTyped) {
            setHasTyped(true);
        }
    });
    return (_jsxs("div", Object.assign({ ref: containerRef, className: isActive ? activeClassName : className }, { children: [_jsx(DropdownContext.Provider, Object.assign({ value: dropdownContext }, { children: _jsx(InputContext.Provider, Object.assign({ value: inputContext }, { children: _jsx(FocusContext.Provider, Object.assign({ value: focusContext }, { children: childrenWithDropdownItemsTransformed }), void 0) }), void 0) }), void 0), _jsx(ScreenReader, { announcementKey: screenReaderKey, announcementText: isActive && (hasTyped || items.length || value) ? screenReaderText : '', instructionsId: screenReaderUUID, instructions: screenReaderInstructions }, void 0)] }), void 0));
}
function useInputContextInstance() {
    const [value, setValue] = useState('');
    const [lastTypedOrSubmittedValue, setLastTypedOrSubmittedValue] = useState('');
    return {
        value,
        setValue,
        lastTypedOrSubmittedValue,
        setLastTypedOrSubmittedValue
    };
}
function useFocusContextInstance(items, lastTypedOrSubmittedValue, setValue, screenReaderKey, setScreenReaderKey, alwaysSelectOption) {
    const [focusedIndex, setFocusedIndex] = useState(-1);
    const [focusedValue, setFocusedValue] = useState(null);
    const [focusedItemData, setFocusedItemData] = useState(undefined);
    useEffect(() => {
        if (alwaysSelectOption) {
            if (items.length > 0) {
                const index = focusedIndex === -1 || focusedIndex >= items.length ? 0 : focusedIndex;
                setFocusedIndex(index);
                setFocusedValue(items[index].value);
                setFocusedItemData(items[index].itemData);
            }
            else {
                setFocusedIndex(-1);
                setFocusedValue(null);
                setFocusedItemData(undefined);
            }
        }
    }, [alwaysSelectOption, focusedIndex, items]);
    function updateFocusedItem(updatedFocusedIndex, value) {
        const numItems = items.length;
        let updatedValue;
        if (updatedFocusedIndex === -1 || updatedFocusedIndex >= numItems || numItems === 0) {
            updatedValue = value !== null && value !== void 0 ? value : lastTypedOrSubmittedValue;
            if (alwaysSelectOption && numItems !== 0) {
                setFocusedIndex(0);
                setFocusedItemData(items[0].itemData);
                setScreenReaderKey(screenReaderKey + 1);
            }
            else {
                setFocusedIndex(-1);
                setFocusedItemData(undefined);
                setScreenReaderKey(screenReaderKey + 1);
            }
        }
        else if (updatedFocusedIndex < -1) {
            const loopedAroundIndex = (numItems + updatedFocusedIndex + 1) % numItems;
            updatedValue = value !== null && value !== void 0 ? value : items[loopedAroundIndex].value;
            setFocusedIndex(loopedAroundIndex);
            setFocusedItemData(items[loopedAroundIndex].itemData);
        }
        else {
            updatedValue = value !== null && value !== void 0 ? value : items[updatedFocusedIndex].value;
            setFocusedIndex(updatedFocusedIndex);
            setFocusedItemData(items[updatedFocusedIndex].itemData);
        }
        setFocusedValue(updatedValue);
        setValue(alwaysSelectOption ? (value !== null && value !== void 0 ? value : lastTypedOrSubmittedValue) : updatedValue);
    }
    return {
        focusedIndex,
        focusedValue,
        focusedItemData,
        updateFocusedItem
    };
}
function useDropdownContextInstance(prevValue, value, index, focusedItemData, screenReaderUUID, setHasTyped, onToggle, onSelect) {
    const [isActive, _toggleDropdown] = useState(false);
    const toggleDropdown = (willBeOpen) => {
        if (!willBeOpen) {
            setHasTyped(false);
        }
        _toggleDropdown(willBeOpen);
        onToggle === null || onToggle === void 0 ? void 0 : onToggle(willBeOpen, prevValue, value, index, focusedItemData);
    };
    return {
        isActive,
        toggleDropdown,
        onSelect,
        screenReaderUUID
    };
}
function getTransformedChildrenAndItemData(children) {
    const items = [];
    const childrenWithDropdownItemsTransformed = recursivelyMapChildren(children, (child => {
        if (!(isValidElement(child) && child.type === DropdownItem)) {
            return child;
        }
        const props = child.props;
        items.push({
            value: props.value,
            itemData: props.itemData
        });
        const transformedItem = createElement(DropdownItemWithIndex, Object.assign(Object.assign({}, props), { index: items.length - 1 }));
        return transformedItem;
    }));
    return [childrenWithDropdownItemsTransformed, items];
}
//# sourceMappingURL=Dropdown.js.map