import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { Matcher } from '@yext/search-headless-react';
import { useCallback, useEffect, useMemo } from 'react';
import { v4 as uuid } from 'uuid';
import { useFiltersContext } from './FiltersContext';
import { useFilterGroupContext } from './FilterGroupContext';
import { useComposedCssClasses } from '../../hooks/useComposedCssClasses';
import { findSelectableFieldValueFilter } from '../../utils/filterutils';
import classNames from 'classnames';
const builtInCssClasses = {
    label: 'text-neutral text-sm font-normal cursor-pointer',
    label___disabled: 'opacity-50 cursor-not-allowed',
    input: 'w-3.5 h-3.5 form-checkbox cursor-pointer border border-gray-300 rounded-sm text-primary focus:ring-primary',
    input___disabled: 'border-gray-200 bg-gray-50 cursor-not-allowed',
    container: 'flex items-center',
    optionContainer: 'flex items-center space-x-3 peer',
    tooltipContainer: 'invisible peer-hover:visible relative -right-5 -top-5',
    tooltip: 'absolute z-10 left-0 -top-0.5 whitespace-nowrap rounded shadow-lg p-3 text-sm bg-neutral-dark text-white'
};
/**
 * A checkbox component that represents a single FieldValueFilter.
 *
 * @public
 *
 * @param props - {@link Filters.CheckboxOptionProps}
 */
export function CheckboxOption(props) {
    var _a, _b;
    const { fieldId, isOptionsDisabled } = useFilterGroupContext();
    const { value, matcher = Matcher.Equals, selectedByDefault = false, displayName = props.value, resultsCount } = props;
    const cssClasses = useComposedCssClasses(builtInCssClasses, props.customCssClasses);
    const optionId = useMemo(() => uuid(), []);
    const { selectFilter, filters, applyFilters } = useFiltersContext();
    const handleClick = useCallback((checked) => {
        selectFilter({
            matcher,
            fieldId,
            value,
            displayName: typeof displayName === 'string' ? displayName : undefined,
            selected: checked
        });
        applyFilters();
    }, [applyFilters, fieldId, displayName, selectFilter, value, matcher]);
    const handleChange = useCallback(evt => {
        handleClick(evt.target.checked);
    }, [handleClick]);
    const optionFilter = useMemo(() => {
        return {
            fieldId,
            matcher,
            value
        };
    }, [fieldId, value, matcher]);
    const existingStoredFilter = findSelectableFieldValueFilter(optionFilter, filters);
    useEffect(() => {
        if (!existingStoredFilter && selectedByDefault) {
            selectFilter(Object.assign(Object.assign({}, optionFilter), { displayName: typeof displayName === 'string' ? displayName : undefined, selected: true }));
        }
    }, [displayName, selectFilter, selectedByDefault, existingStoredFilter, optionFilter]);
    const isSelected = existingStoredFilter ? existingStoredFilter.selected : false;
    const labelText = resultsCount ? `${displayName} (${resultsCount})` : displayName;
    const inputClasses = classNames(cssClasses.input, {
        [(_a = cssClasses.input___disabled) !== null && _a !== void 0 ? _a : '']: isOptionsDisabled
    });
    const labelClasses = classNames(cssClasses.label, {
        [(_b = cssClasses.label___disabled) !== null && _b !== void 0 ? _b : '']: isOptionsDisabled
    });
    return (_jsxs("div", Object.assign({ className: cssClasses.container }, { children: [_jsxs("div", Object.assign({ className: cssClasses.optionContainer }, { children: [_jsx("input", { type: 'checkbox', id: optionId, checked: isSelected, className: inputClasses, onChange: handleChange, disabled: isOptionsDisabled }, void 0), _jsx("label", Object.assign({ className: labelClasses, htmlFor: optionId }, { children: labelText }), void 0)] }), void 0), isOptionsDisabled &&
                _jsx("div", Object.assign({ className: cssClasses.tooltipContainer }, { children: _jsx("div", Object.assign({ className: cssClasses.tooltip }, { children: "Clear the range to select options." }), void 0) }), void 0)] }), void 0));
}
//# sourceMappingURL=CheckboxOption.js.map