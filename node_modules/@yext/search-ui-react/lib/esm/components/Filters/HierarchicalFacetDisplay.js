import { jsx as _jsx } from "react/jsx-runtime";
import { useCallback, useState } from 'react';
import { useComposedCssClasses } from '../../hooks/useComposedCssClasses';
import { useHierarchicalFacetTree } from '../../hooks/useHierarchicalFacetTree';
import { useFiltersContext } from './FiltersContext';
const builtInCssClasses = {
    treeContainer: 'flex flex-col items-start',
    allCategoriesOption___active: 'font-semibold mb-2 text-sm',
    allCategoriesOption___inactive: 'mb-2 text-sm',
    availableOption__active: 'font-semibold ml-4 mb-2 text-sm',
    availableOption__inactive: 'ml-4 mb-2 text-sm',
    parentCategory: 'mb-2 text-sm',
    currentCategory: 'font-semibold mb-2 text-sm',
    showMoreButton: 'ml-4 text-sm font-medium text-primary'
};
export const DEFAULT_HIERARCHICAL_DELIMITER = '>';
/**
 * A HierarchicalFacetDisplay takes a `DisplayableFacet` and renders the facet in a way
 * to represent multiple levels of "hierarchies".
 *
 * The hierarchies are determined by the provided delimiter, which defaults to "\>".
 *
 * @public
 */
export function HierarchicalFacetDisplay({ facet, delimiter = DEFAULT_HIERARCHICAL_DELIMITER, showMoreLimit = 4, customCssClasses }) {
    const cssClasses = useComposedCssClasses(builtInCssClasses, customCssClasses);
    const tree = useHierarchicalFacetTree(facet, delimiter);
    const [isShowingMore, setIsShowingMore] = useState(false);
    const resetShowMore = useCallback(() => setIsShowingMore(false), []);
    const toggleShowMore = useCallback(() => {
        setIsShowingMore(!isShowingMore);
    }, [isShowingMore]);
    /** Iteratively parses the `HierarchicalFacetTree` into an array of ReactNodes */
    function renderTree() {
        let treePointer = tree;
        const renderedNodesAndShowMoreButton = [renderAllCategoriesButton()];
        while (treePointer) {
            const currentNodes = Object.values(treePointer);
            const selectedChildNode = currentNodes.find(n => n.selected);
            const selectedHasNoChildren = selectedChildNode && Object.values(selectedChildNode.childTree).length === 0;
            const activeParentNode = currentNodes.find(n => n.hasSelectedChild);
            if ((!selectedChildNode && !activeParentNode) || selectedHasNoChildren) {
                renderedNodesAndShowMoreButton.push(...renderAvailableOptions(currentNodes));
                if (currentNodes.length > showMoreLimit) {
                    renderedNodesAndShowMoreButton.push(renderShowMoreButton());
                }
                break;
            }
            const activeNode = selectedChildNode !== null && selectedChildNode !== void 0 ? selectedChildNode : activeParentNode;
            if (!activeNode) {
                break;
            }
            renderedNodesAndShowMoreButton.push(renderCategory(activeNode, facet.fieldId));
            treePointer = activeNode.childTree;
        }
        return renderedNodesAndShowMoreButton;
    }
    function renderAllCategoriesButton() {
        return (_jsx(AllCategories, { activeClassName: cssClasses.allCategoriesOption___active, inactiveClassName: cssClasses.allCategoriesOption___inactive, facet: facet, resetShowMore: resetShowMore }, '_AllCategories'));
    }
    function renderAvailableOptions(nodes) {
        const nodesToRender = isShowingMore ? nodes : nodes.slice(0, showMoreLimit);
        return nodesToRender.map(n => _jsx(AvailableOption, { activeClassName: cssClasses.availableOption__active, inactiveClassName: cssClasses.availableOption__inactive, fieldId: facet.fieldId, currentNode: n, resetShowMore: resetShowMore, siblingNodes: nodes.filter(siblingNode => siblingNode !== n) }, n.lastDisplayNameToken));
    }
    function renderShowMoreButton() {
        return _jsx(ShowMoreButton, { className: cssClasses.showMoreButton, isShowingMore: isShowingMore, toggleShowMore: toggleShowMore }, '_ShowMoreButton');
    }
    function renderCategory(selectedNode, fieldId) {
        const sharedProps = {
            key: selectedNode.lastDisplayNameToken,
            resetShowMore,
            selectedNode,
            fieldId
        };
        if (selectedNode.hasSelectedChild) {
            return _jsx(ParentCategory, Object.assign({ className: cssClasses.parentCategory }, sharedProps), void 0);
        }
        else {
            return _jsx(CurrentCategory, Object.assign({ className: cssClasses.currentCategory }, sharedProps), void 0);
        }
    }
    return (_jsx("div", Object.assign({ className: cssClasses.treeContainer }, { children: renderTree() }), void 0));
}
/**
 * A hard-coded "All Categories" button that can be used to reset the HierarchicalFacetDisplay
 * to its initial state, i.e. with no options selected.
 */
function AllCategories({ facet, inactiveClassName, activeClassName, resetShowMore }) {
    const { applyFilters, selectFilter } = useFiltersContext();
    const handleClickAllCategories = useCallback(() => {
        facet.options
            .filter(o => o.selected)
            .forEach(o => selectFilter(Object.assign(Object.assign({}, o), { fieldId: facet.fieldId, selected: false })));
        applyFilters();
        resetShowMore();
    }, [applyFilters, facet.fieldId, facet.options, resetShowMore, selectFilter]);
    if (facet.options.find(o => o.selected)) {
        return (_jsx("button", Object.assign({ className: inactiveClassName, onClick: handleClickAllCategories }, { children: "All Categories /" }), void 0));
    }
    return (_jsx("div", Object.assign({ className: activeClassName }, { children: "All Categories" }), void 0));
}
/** An option currently available for selection or deselection. */
function AvailableOption(props) {
    var _a;
    const { fieldId, currentNode, activeClassName, inactiveClassName, resetShowMore, siblingNodes } = props;
    const { applyFilters, selectFilter } = useFiltersContext();
    const { selected, lastDisplayNameToken, facetOption } = currentNode;
    const handleClickAvailableOptions = useCallback(() => {
        var _a;
        siblingNodes.filter(n => n.selected).forEach(n => selectFilter(Object.assign(Object.assign({}, n.facetOption), { selected: false, fieldId })));
        selectFilter(Object.assign(Object.assign({}, facetOption), { selected: !selected, fieldId }));
        const parentFacetOption = (_a = currentNode.parentNode) === null || _a === void 0 ? void 0 : _a.facetOption;
        parentFacetOption && selectFilter(Object.assign(Object.assign({}, parentFacetOption), { selected,
            fieldId }));
        applyFilters();
        resetShowMore();
    }, [
        applyFilters,
        (_a = currentNode.parentNode) === null || _a === void 0 ? void 0 : _a.facetOption,
        facetOption,
        fieldId,
        resetShowMore,
        selectFilter,
        selected,
        siblingNodes
    ]);
    return (_jsx("button", Object.assign({ className: selected ? activeClassName : inactiveClassName, onClick: handleClickAvailableOptions }, { children: lastDisplayNameToken }), void 0));
}
/** A parent category that is not the most immediate one. */
function ParentCategory({ fieldId, selectedNode, className, resetShowMore }) {
    const { applyFilters, selectFilter } = useFiltersContext();
    const deselectChildOptions = useCallback((node) => {
        const tree = node.childTree;
        Object.values(tree).forEach(n => {
            selectFilter(Object.assign(Object.assign({}, n.facetOption), { selected: false, fieldId }));
            deselectChildOptions(n);
        });
    }, [fieldId, selectFilter]);
    const handleClickParentCategory = useCallback(() => {
        selectFilter(Object.assign(Object.assign({}, selectedNode.facetOption), { selected: true, fieldId }));
        deselectChildOptions(selectedNode);
        applyFilters();
        resetShowMore();
    }, [applyFilters, deselectChildOptions, fieldId, resetShowMore, selectFilter, selectedNode]);
    return (_jsx("button", Object.assign({ className: className, onClick: handleClickParentCategory }, { children: selectedNode.lastDisplayNameToken + ' /' }), void 0));
}
/** The currently selected category, i.e. the most immediate category. */
function CurrentCategory({ fieldId, selectedNode, className, resetShowMore }) {
    var _a;
    const { applyFilters, selectFilter } = useFiltersContext();
    const handleClickCurrentCategory = useCallback(() => {
        var _a;
        selectFilter(Object.assign(Object.assign({}, selectedNode.facetOption), { selected: false, fieldId }));
        const parentFacetOption = (_a = selectedNode.parentNode) === null || _a === void 0 ? void 0 : _a.facetOption;
        parentFacetOption && selectFilter(Object.assign(Object.assign({}, parentFacetOption), { selected: true, fieldId }));
        applyFilters();
        resetShowMore();
    }, [
        applyFilters,
        fieldId,
        resetShowMore,
        selectFilter,
        selectedNode.facetOption,
        (_a = selectedNode.parentNode) === null || _a === void 0 ? void 0 : _a.facetOption
    ]);
    return (_jsx("button", Object.assign({ className: className, onClick: handleClickCurrentCategory }, { children: selectedNode.lastDisplayNameToken }), void 0));
}
/** The "Show more/less" button for hiding/showing additional `AvailableOption`s */
function ShowMoreButton({ className, isShowingMore, toggleShowMore }) {
    return (_jsx("button", Object.assign({ className: className, onClick: toggleShowMore }, { children: isShowingMore ? 'Show less' : 'Show more' }), void 0));
}
//# sourceMappingURL=HierarchicalFacetDisplay.js.map