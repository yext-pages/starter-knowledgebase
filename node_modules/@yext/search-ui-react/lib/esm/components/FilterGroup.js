var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { createElement as _createElement } from "react";
import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { useSearchUtilities } from '@yext/search-headless-react';
import { useMemo, useState } from 'react';
import { CheckboxOption, CollapsibleLabel, CollapsibleSection, SearchInput, FilterGroupProvider, useFilterGroupContext } from './Filters';
/**
 * Renders a group of selectable filters with support for searching and collapsing.
 */
export function FilterGroup({ fieldId, filterOptions, title, collapsible = true, defaultExpanded = true, searchable, customCssClasses = {}, showMoreLimit = filterOptions.length, children }) {
    const cssClasses = useMemo(() => {
        const { option, optionLabel, optionInput } = customCssClasses, remainingClasses = __rest(customCssClasses, ["option", "optionLabel", "optionInput"]);
        return Object.assign(Object.assign(Object.assign(Object.assign({}, remainingClasses), option && { optionContainer: option }), optionLabel && { label: optionLabel }), optionInput && { input: optionInput });
    }, [customCssClasses]);
    function renderTitle() {
        return collapsible
            ? _jsx(CollapsibleLabel, { label: title }, void 0)
            : (title &&
                _jsx("div", Object.assign({ className: 'text-neutral-dark text-sm font-medium text-left mb-4' }, { children: title }), void 0));
    }
    return (_jsxs(FilterGroupProvider, Object.assign({ fieldId: fieldId, defaultExpanded: !collapsible || defaultExpanded }, { children: [renderTitle(), _jsxs(CollapsibleSection, Object.assign({ className: cssClasses.optionsContainer }, { children: [searchable && _jsx(SearchInput, { className: cssClasses.searchInput }, void 0), _jsx(CheckboxOptions, { filterOptions: filterOptions, showMoreLimit: showMoreLimit, cssClasses: cssClasses }, void 0), children] }), void 0)] }), void 0));
}
function CheckboxOptions({ filterOptions, showMoreLimit, cssClasses }) {
    const searchUtilities = useSearchUtilities();
    const { searchValue } = useFilterGroupContext();
    const shouldRenderOption = (option) => {
        return searchUtilities.isCloseMatch(option.displayName || option.value.toString(), searchValue);
    };
    let displayedOptions = filterOptions.filter(shouldRenderOption).map(o => {
        return (_createElement(CheckboxOption, Object.assign({}, o, { key: o.displayName || o.value.toString(), customCssClasses: cssClasses })));
    });
    const isLimited = displayedOptions.length > showMoreLimit;
    const [showAll, setShowAll] = useState(!isLimited);
    displayedOptions = displayedOptions.slice(0, showAll ? displayedOptions.length : showMoreLimit);
    return (_jsxs(_Fragment, { children: [displayedOptions, isLimited &&
                /* eslint-disable-next-line react-perf/jsx-no-new-function-as-prop */
                _jsx("button", Object.assign({ className: 'text-primary py-1 text-sm', onClick: () => setShowAll(!showAll) }, { children: showAll ? 'Show Less' : 'Show More' }), void 0)] }, void 0));
}
//# sourceMappingURL=FilterGroup.js.map