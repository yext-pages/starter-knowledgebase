import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { QuerySource, SearchTypeEnum, useSearchActions, useSearchState, useSearchUtilities } from '@yext/search-headless-react';
import classNames from 'classnames';
import { Fragment, isValidElement, useCallback, useEffect, useMemo } from 'react';
import { useEntityPreviews } from '../hooks/useEntityPreviews';
import { useRecentSearches } from '../hooks/useRecentSearches';
import { useSearchWithNearMeHandling } from '../hooks/useSearchWithNearMeHandling';
import { useSynchronizedRequest } from '../hooks/useSynchronizedRequest';
import { VerticalDividerIcon } from '../icons/VerticalDividerIcon';
import { HistoryIcon as RecentSearchIcon } from '../icons/HistoryIcon';
import { CloseIcon } from '../icons/CloseIcon';
import { MagnifyingGlassIcon } from '../icons/MagnifyingGlassIcon';
import { YextIcon } from '../icons/YextIcon';
import { Dropdown } from './Dropdown/Dropdown';
import { useDropdownContext } from './Dropdown/DropdownContext';
import { DropdownInput } from './Dropdown/DropdownInput';
import { DropdownItem } from './Dropdown/DropdownItem';
import { DropdownMenu } from './Dropdown/DropdownMenu';
import { useComposedCssClasses, twMerge } from '../hooks/useComposedCssClasses';
import { SearchButton } from './SearchButton';
import { processTranslation } from './utils/processTranslation';
import { renderAutocompleteResult, builtInCssClasses as AutocompleteResultBuiltInCssClasses } from './utils/renderAutocompleteResult';
import { useSearchBarAnalytics } from '../hooks/useSearchBarAnalytics';
import { isVerticalLink } from '../models/verticalLink';
import { executeAutocomplete as executeAutocompleteSearch } from '../utils/search-operations';
import { clearStaticRangeFilters } from '../utils/filterutils';
import { recursivelyMapChildren } from './utils/recursivelyMapChildren';
const builtInCssClasses = Object.assign({ searchBarContainer: 'h-12 mb-6', inputDivider: 'border-t border-gray-200 mx-2.5', inputElement: 'outline-none flex-grow border-none h-full pl-0.5 pr-2 text-neutral-dark text-base placeholder:text-neutral-light', searchButtonContainer: ' w-8 h-full mx-2 flex flex-col justify-center items-center', searchButton: 'h-7 w-7', focusedOption: 'bg-gray-100', clearButton: 'h-3 w-3 mr-3.5', verticalDivider: 'mr-0.5', recentSearchesIcon: 'w-5 mr-1 text-gray-400', recentSearchesOption: 'pl-3 text-neutral-dark', recentSearchesNonHighlighted: 'font-normal', verticalLink: 'ml-12 pl-1 text-neutral italic', entityPreviewsDivider: 'h-px bg-gray-200 mt-1 mb-4 mx-3.5' }, AutocompleteResultBuiltInCssClasses);
/**
 * Renders a SearchBar that is hooked up with an InputDropdown component.
 *
 * @public
 */
export function SearchBar({ placeholder, geolocationOptions, hideRecentSearches, visualAutocompleteConfig, showVerticalLinks = false, onSelectVerticalLink, verticalKeyToLabel, recentSearchesLimit = 5, customCssClasses, onSearch }) {
    var _a;
    const { entityPreviewSearcher, renderEntityPreviews, includedVerticals, universalLimit, entityPreviewsDebouncingTime = 500 } = visualAutocompleteConfig !== null && visualAutocompleteConfig !== void 0 ? visualAutocompleteConfig : {};
    const searchActions = useSearchActions();
    const searchUtilities = useSearchUtilities();
    const reportAnalyticsEvent = useSearchBarAnalytics();
    const query = (_a = useSearchState(state => state.query.input)) !== null && _a !== void 0 ? _a : '';
    const cssClasses = useComposedCssClasses(builtInCssClasses, customCssClasses);
    const isVertical = useSearchState(state => state.meta.searchType) === SearchTypeEnum.Vertical;
    const verticalKey = useSearchState(state => state.vertical.verticalKey);
    const [autocompleteResponse, executeAutocomplete, clearAutocompleteData] = useSynchronizedRequest(() => executeAutocompleteSearch(searchActions));
    const [executeQueryWithNearMeHandling, autocompletePromiseRef,] = useSearchWithNearMeHandling(geolocationOptions, onSearch);
    const [recentSearches, setRecentSearch, clearRecentSearches,] = useRecentSearches(recentSearchesLimit, verticalKey);
    const filteredRecentSearches = recentSearches === null || recentSearches === void 0 ? void 0 : recentSearches.filter(search => searchUtilities.isCloseMatch(search.query, query));
    useEffect(() => {
        if (hideRecentSearches) {
            clearRecentSearches();
        }
    }, [clearRecentSearches, hideRecentSearches]);
    const clearAutocomplete = useCallback(() => {
        clearAutocompleteData();
        autocompletePromiseRef.current = undefined;
    }, [autocompletePromiseRef, clearAutocompleteData]);
    const executeQuery = useCallback(() => {
        if (!hideRecentSearches) {
            const input = searchActions.state.query.input;
            input && setRecentSearch(input);
        }
        executeQueryWithNearMeHandling();
    }, [
        searchActions.state.query.input,
        executeQueryWithNearMeHandling,
        hideRecentSearches,
        setRecentSearch
    ]);
    const handleSubmit = useCallback((value, index, itemData) => {
        value !== undefined && searchActions.setQuery(value);
        searchActions.setOffset(0);
        searchActions.setFacets([]);
        clearStaticRangeFilters(searchActions);
        if (itemData && isVerticalLink(itemData.verticalLink) && onSelectVerticalLink) {
            onSelectVerticalLink({ verticalLink: itemData.verticalLink, querySource: QuerySource.Autocomplete });
        }
        else {
            executeQuery();
        }
        if (typeof index === 'number' && index >= 0 && !(itemData === null || itemData === void 0 ? void 0 : itemData.isEntityPreview)) {
            reportAnalyticsEvent('AUTO_COMPLETE_SELECTION', value);
        }
    }, [searchActions, executeQuery, onSelectVerticalLink, reportAnalyticsEvent]);
    const [entityPreviewsState, executeEntityPreviewsQuery] = useEntityPreviews(entityPreviewSearcher, entityPreviewsDebouncingTime);
    const { verticalKeyToResults, isLoading: entityPreviewsLoading } = entityPreviewsState;
    const entityPreviews = renderEntityPreviews === null || renderEntityPreviews === void 0 ? void 0 : renderEntityPreviews(entityPreviewsLoading, verticalKeyToResults, { onClick: handleSubmit, ariaLabel: getAriaLabel });
    const updateEntityPreviews = useCallback((query) => {
        if (!renderEntityPreviews || !includedVerticals) {
            return;
        }
        executeEntityPreviewsQuery(query, universalLimit !== null && universalLimit !== void 0 ? universalLimit : {}, includedVerticals);
    }, [executeEntityPreviewsQuery, renderEntityPreviews, includedVerticals, universalLimit]);
    const handleInputFocus = useCallback((value = '') => {
        searchActions.setQuery(value);
        updateEntityPreviews(value);
        autocompletePromiseRef.current = executeAutocomplete();
    }, [searchActions, autocompletePromiseRef, executeAutocomplete, updateEntityPreviews]);
    const handleInputChange = useCallback((value = '') => {
        searchActions.setQuery(value);
        updateEntityPreviews(value);
        autocompletePromiseRef.current = executeAutocomplete();
    }, [searchActions, autocompletePromiseRef, executeAutocomplete, updateEntityPreviews]);
    const handleClickClearButton = useCallback(() => {
        updateEntityPreviews('');
        handleSubmit('');
        reportAnalyticsEvent('SEARCH_CLEAR_BUTTON');
    }, [handleSubmit, reportAnalyticsEvent, updateEntityPreviews]);
    function renderInput() {
        return (_jsx(DropdownInput, { className: cssClasses.inputElement, placeholder: placeholder, onSubmit: handleSubmit, onFocus: handleInputFocus, onChange: handleInputChange, ariaLabel: 'Conduct a search' }, void 0));
    }
    function renderRecentSearches() {
        const recentSearchesCssClasses = {
            icon: cssClasses.recentSearchesIcon,
            option: cssClasses.recentSearchesOption,
            nonHighlighted: cssClasses.recentSearchesNonHighlighted
        };
        return filteredRecentSearches === null || filteredRecentSearches === void 0 ? void 0 : filteredRecentSearches.map((result, i) => (_jsx(DropdownItem, Object.assign({ className: 'flex items-center h-6.5 px-3.5 py-1.5 cursor-pointer hover:bg-gray-100', focusedClassName: twMerge('flex items-center h-6.5 px-3.5 py-1.5 cursor-pointer hover:bg-gray-100', cssClasses.focusedOption), value: result.query, onClick: handleSubmit }, { children: renderAutocompleteResult({ value: result.query }, recentSearchesCssClasses, RecentSearchIcon, `recent search: ${result.query}`) }), i)));
    }
    const itemDataMatrix = useMemo(() => {
        var _a;
        return (_a = autocompleteResponse === null || autocompleteResponse === void 0 ? void 0 : autocompleteResponse.results.map(result => {
            var _a, _b;
            return (_b = (_a = result.verticalKeys) === null || _a === void 0 ? void 0 : _a.map(verticalKey => ({
                verticalLink: { verticalKey, query: result.value }
            }))) !== null && _b !== void 0 ? _b : [];
        })) !== null && _a !== void 0 ? _a : [];
    }, [autocompleteResponse === null || autocompleteResponse === void 0 ? void 0 : autocompleteResponse.results]);
    function renderQuerySuggestions() {
        return autocompleteResponse === null || autocompleteResponse === void 0 ? void 0 : autocompleteResponse.results.map((result, i) => {
            var _a;
            return (_jsxs(Fragment, { children: [_jsx(DropdownItem, Object.assign({ className: 'flex items-stretch py-1.5 px-3.5 cursor-pointer hover:bg-gray-100', focusedClassName: twMerge('flex items-stretch py-1.5 px-3.5 cursor-pointer hover:bg-gray-100', cssClasses.focusedOption), value: result.value, onClick: handleSubmit }, { children: renderAutocompleteResult(result, cssClasses, MagnifyingGlassIcon, `autocomplete suggestion: ${result.value}`) }), void 0), showVerticalLinks && !isVertical && ((_a = result.verticalKeys) === null || _a === void 0 ? void 0 : _a.map((verticalKey, j) => (_jsx(DropdownItem, Object.assign({ className: 'flex items-stretch py-1.5 px-3.5 cursor-pointer hover:bg-gray-100', focusedClassName: twMerge('flex items-stretch py-1.5 px-3.5 cursor-pointer hover:bg-gray-100', cssClasses.focusedOption), value: result.value, itemData: itemDataMatrix[i][j], onClick: handleSubmit }, { children: renderAutocompleteResult({ value: `in ${verticalKeyToLabel ? verticalKeyToLabel(verticalKey) : verticalKey}` }, Object.assign(Object.assign({}, cssClasses), { option: cssClasses.verticalLink })) }), j))))] }, i));
        });
    }
    function renderClearButton() {
        return (_jsxs(_Fragment, { children: [_jsx("button", Object.assign({ "aria-label": 'Clear the search bar', className: cssClasses.clearButton, onClick: handleClickClearButton }, { children: _jsx(CloseIcon, {}, void 0) }), void 0), _jsx(VerticalDividerIcon, { className: cssClasses.verticalDivider }, void 0)] }, void 0));
    }
    const entityPreviewsCount = calculateEntityPreviewsCount(entityPreviews);
    const showEntityPreviewsDivider = entityPreviews
        && !!((autocompleteResponse === null || autocompleteResponse === void 0 ? void 0 : autocompleteResponse.results.length) || (filteredRecentSearches === null || filteredRecentSearches === void 0 ? void 0 : filteredRecentSearches.length));
    const hasItems = !!((autocompleteResponse === null || autocompleteResponse === void 0 ? void 0 : autocompleteResponse.results.length)
        || (filteredRecentSearches === null || filteredRecentSearches === void 0 ? void 0 : filteredRecentSearches.length) || entityPreviews);
    const screenReaderText = getScreenReaderText(autocompleteResponse === null || autocompleteResponse === void 0 ? void 0 : autocompleteResponse.results.length, filteredRecentSearches === null || filteredRecentSearches === void 0 ? void 0 : filteredRecentSearches.length, entityPreviewsCount);
    const activeClassName = classNames('relative z-10 bg-white border rounded-3xl border-gray-200 w-full overflow-hidden', {
        ['shadow-lg' !== null && 'shadow-lg' !== void 0 ? 'shadow-lg' : '']: hasItems
    });
    const handleToggleDropdown = useCallback((isActive) => {
        if (!isActive) {
            clearAutocomplete();
        }
    }, [clearAutocomplete]);
    return (_jsx("div", Object.assign({ className: cssClasses.searchBarContainer }, { children: _jsxs(Dropdown, Object.assign({ className: 'relative bg-white border rounded-3xl border-gray-200 w-full overflow-hidden', activeClassName: activeClassName, screenReaderText: screenReaderText, parentQuery: query, onToggle: handleToggleDropdown }, { children: [_jsxs("div", Object.assign({ className: 'inline-flex items-center justify-between w-full' }, { children: [_jsx("div", Object.assign({ className: 'w-7 mx-2.5 my-2' }, { children: _jsx(YextIcon, {}, void 0) }), void 0), renderInput(), query && renderClearButton(), _jsx(DropdownSearchButton, { handleSubmit: handleSubmit, cssClasses: cssClasses }, void 0)] }), void 0), hasItems &&
                    _jsxs(StyledDropdownMenu, Object.assign({ cssClasses: cssClasses }, { children: [renderRecentSearches(), renderQuerySuggestions(), showEntityPreviewsDivider && _jsx("div", { className: cssClasses.entityPreviewsDivider }, void 0), entityPreviews] }), void 0)] }), void 0) }), void 0));
}
function StyledDropdownMenu({ cssClasses, children }) {
    return (_jsxs(DropdownMenu, { children: [_jsx("div", { className: cssClasses.inputDivider }, void 0), _jsx("div", Object.assign({ className: 'bg-white py-4' }, { children: children }), void 0)] }, void 0));
}
function getScreenReaderText(autocompleteOptions = 0, recentSearchesOptions = 0, entityPreviewsCount = 0) {
    const recentSearchesText = recentSearchesOptions > 0
        ? processTranslation({
            phrase: `${recentSearchesOptions} recent search found.`,
            pluralForm: `${recentSearchesOptions} recent searches found.`,
            count: recentSearchesOptions
        })
        : '';
    const entityPreviewsText = entityPreviewsCount > 0
        ? ' ' + processTranslation({
            phrase: `${entityPreviewsCount} result preview found.`,
            pluralForm: `${entityPreviewsCount} result previews found.`,
            count: entityPreviewsCount
        })
        : '';
    const autocompleteText = autocompleteOptions > 0
        ? ' ' + processTranslation({
            phrase: `${autocompleteOptions} autocomplete suggestion found.`,
            pluralForm: `${autocompleteOptions} autocomplete suggestions found.`,
            count: autocompleteOptions
        })
        : '';
    const text = recentSearchesText + autocompleteText + entityPreviewsText;
    if (text === '') {
        return processTranslation({
            phrase: '0 autocomplete suggestion found.',
            pluralForm: '0 autocomplete suggestions found.',
            count: 0
        });
    }
    return text.trim();
}
function DropdownSearchButton({ handleSubmit, cssClasses }) {
    const { toggleDropdown } = useDropdownContext();
    const handleClick = useCallback(() => {
        handleSubmit();
        toggleDropdown(false);
    }, [handleSubmit, toggleDropdown]);
    return (_jsx("div", Object.assign({ className: cssClasses.searchButtonContainer }, { children: _jsx(SearchButton, { className: cssClasses.searchButton, handleClick: handleClick }, void 0) }), void 0));
}
function getAriaLabel(value) {
    return 'result preview: ' + value;
}
/**
 * Calculates the number of navigable entity previews from a ReactNode containing DropdownItems.
 */
export function calculateEntityPreviewsCount(children) {
    let count = 0;
    recursivelyMapChildren(children, c => {
        if (isValidElement(c) && c.type === DropdownItem) {
            count++;
        }
        return c;
    });
    return count;
}
//# sourceMappingURL=SearchBar.js.map